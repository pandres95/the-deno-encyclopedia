# Preface {.unnumbered}

Initially, I want to thank you for taking the step to read The Deno
Encyclopedia. Having you here means a lot to me.

For the last ten years, the resources people have at their disposal to learn
concepts related to tech, software development, and the digital economy have
tended to grow almost exponentially.

YouTube, eBooks, MOOCs, online courses, education platforms, and online
Bootcamps, as well as other wonders of modern education. All of that at the
distance of a click. It is fair to say that we're living in the best moment
possible to start learning anything by your initiative, either by fun or by
merely applying that knowledge professionally.

It's amazing! I can't help but wonder how lucky new generations are, living at
the peak of the democratization of education unseen in decades (or even
centuries).

I was 11 when I took my first programming class. It was 2006 when programming
wasn't that popular, but it was a career you had to go to college to learn it.
YouTube programming courses weren't a thing, GitHub didn't even exist, and the
best documentation was college textbooks.

For me, the _"Hello world"_ was a tutorial of Visual Basic for Applications, a
legacy language that is, however, used these days to write scripts for Microsoft
Office. That tutorial was for elementary school teachers learning to use _"new
technologies"_ in classrooms. While I doubt many of them had learned to code, it
would open an exciting world to me.

That way, my introductory course was me self-learning to build applications in
PowerPoint by trial and error.

I wrote a couple of _apps_. Both were trivia-like games that would take a
response option of a question as input and would output a prompt saying whether
the response was correct or not. I would later iterate to count the number of
correct answers.

Meanwhile, I was trying to find on the internet how to make those _"apps"_ run
without having PowerPoint installed. I didn't progress much in the following
months.

I didn't know where else to look and honestly didn't care much. In the end, I
was still 11, more interested in watching TV, listening to music, playing piano
after class, and struggling with all that being teenager stuff.

Months later, I'll receive my first proper book to learn a programming language
and how to use it to create real-world applications. That book had twenty
chapters. Each of them was an introduction to using the building blocks of that
programming language I started learning months ago.

It would take me four months to build my first application. It was an
application designed to cast votes in school elections (those where you vote for
the classroom president). I showed the program to my computing teacher. He was
impressed. That encouraged me to ask the principal to use it in the next
elections in the following weeks.

The UI was excellent, coming from a 12-year-old kid making his first actual
desktop application ever.

The response to my request was an absolute yes!

I did some tests in the computer lab, set up some computers to use the program,
and got rest, preparing for the day. I remember being praised by some teachers
these days and being called a genius and _"the next _Bill Gates_."

At this point, you'd probably guessed this story's most hilarious part: the
program failed spectacularly! The program couldn't cast more than 5 or 6 votes
before freezing and crashing. In the end, I couldn't run fast enough to go and
try to fix the program on every computer enabled for those elections.

The principal called me and told me that he'd cancel the elections that day and,
instead, they were running old-fashioned elections using paper ballots the
following Monday.

Honestly, in retrospect, my program's issues weren't that bad. I only had to
move the images out of the database and close the connection after every query
or transaction.

Those were clear instructions I would learn a year later after buying a book
about databases. However, I would never fix that application. Instead, I would
take the classic junior approach of redoing it from scratch on newer technology
and, in practice going back to the beginning of my learning curve.

In the following years, I would spend my spare time going to a coworking space
—a real milestone to have one nearby— to have someone to teach me those new
technologies. I would also get more books from teachers and early mentors. And
mostly, I'd spend my time going to the local library every other week to borrow
three or four wordy books. I would read about C++ and Java. And took online
tutorials about Flash with ActionScript and HTML (the first ones I remember to
have read online) but never finished that application ever again.

I did some other things, though. I learned to use trees to make knowledge bases,
the basics of Computer Vision, and face recognition (something that we take for
granted today).

I made a DJ application for my school's radio station —that was pretty cool—. I
started working on an inventory application I thought would become an online
portfolio for my uncle's shoemaking business (another project I never finished).

Then, in college, one teacher would give me the first book I'd read about
Python. To me, it was a novelty to read an open-sourced book.

It took me no more than two or three hours to make a Python application. After
that, it would take a couple of months before doing my first talk (about
Python). And just a year after, I signed my first job in software development,
building Android applications.

You might think the lesson here is to enroll yourself in college. Sure! It's
true that for some people, it's not a feasible option for lots of other people.

In contrast, what I can say for sure, sped up my career was having access to a
broader set of resources online: tutorials, official documentation and
references, and courses that complemented my formal education.

The main difference between technical books and textbooks is that the first ones
guide you, while the second ones offer concepts. The best books I've read,
however, achieve both. I would have thanked that one of those books I devoured
as the bookworm I am was at least a bit close to being a guideline, more than a
textbook.

All of this is to say thanks for being part of this adventure. Of reading a book
inspired by this journey. Of getting on your hands, a reading that would take
you to the concepts you need to acquire and then guide you to go further and
take advantage of that vast world of information out there.

Welcome to the adventure of reading The Deno Encyclopedia.

# To the reader {.unnumbered}

## The purpose of this book {.unnumbered}

The existence of a whole world of possibilities doesn't necessarily mean any
resource out there will be as effective in getting you where you want to be.
Sometimes you might find it helpful to have a quick reference guide or a cheat
sheet.

Anyways, a resource that can quickly and intuitively introduce you to the
concepts that shape a particular technology. That is precisely the purpose of
this book.

### What this book is not {.unnumbered}

Before you get your hopes way up, let me give you a friendly warning. I didn't
write this book to _"drive you through the state of the art of Deno"_.

I acknowledge the limitations of what a technical book can do to give you the
latest tech over time.

Honestly, at the time of writing this, and if you're reading this book ten years
in the future, just out of curiosity, I won't be able to keep the promise that
even YouTube will exist; highly possible that it will, yet I'm not entirely
sure.

So yes! Books get old, and that's not necessarily a bad thing. OOP is a concept
created in the 80s. And it's okay to learn algebra from books written back in
the mid-50s, like we use physics formulas developed 300 years ago.

Technologies get old and obsolete, and you should not judge a book by how
_"up-to-date"_ they look.

Concepts, however, are timeless.

### What this book is {.unnumbered}

And that's the point: I mean this book to give you an introductory course for
learning a Javascript runtime (note I've said two technologies), but
prioritizing that you know the concepts behind and understand the key behind
gaining experience with a product of technology: know what to search.

Once you finish reading this book, you will be able to:

- Understand the motivation behind Deno's creation.
- Manage the most basic concepts and syntax of the language. And know where to
  study the language in depth (spoiler, there's a whole world of open-source
  ebooks about this topic).
- Get started on your first projects using Deno.
- Enjoy the process.

In conclusion: this book is just a giant attempt to write a digestible README of
what Deno is and how to use it.

## How to read this book {.unnumbered}

<!-- 
TODO: Explain how to read this book, and the structure of the following chapters.

To do so, I'll need to further develop the structure of such chapters. -->